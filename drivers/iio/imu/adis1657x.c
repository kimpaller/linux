// SPDX-License-Identifier: GPL-2.0
/*
 * adis1657x IMU driver
 *
 * Copyright 2023 Analog Devices Inc.
 */
#include <linux/iio/iio.h>
#include <linux/iio/imu/adis.h>
#include <linux/iio/imu/adis_extd.h>
#include <linux/module.h>
#include <linux/mod_devicetable.h>
#include <linux/spi/spi.h>
#include <linux/units.h>

/** @struct adis1657x_variant
 *  @brief ADIS1657X supported ids
 */
enum adis1657x_variant {
	ADIS16575_2,
	ADIS16575_3,
	ADIS16576_2,
	ADIS16576_3,
	ADIS16577_2,
	ADIS16577_3,
};

static const struct adis_extd_data_field_map_def adis1657x_def = {
	.x_gyro			= {.reg_addr = 0x04, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.y_gyro			= {.reg_addr = 0x08, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.z_gyro			= {.reg_addr = 0x0C, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.x_accl			= {.reg_addr = 0x10, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.y_accl			= {.reg_addr = 0x14, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.z_accl			= {.reg_addr = 0x18, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.temp_out		= {.reg_addr = 0x1C, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.time_stamp		= {.reg_addr = 0x1E, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.data_cntr		= {.reg_addr = 0x22, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.x_deltang		= {.reg_addr = 0x24, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.y_deltang		= {.reg_addr = 0x28, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.z_deltang		= {.reg_addr = 0x2C, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.x_deltvel		= {.reg_addr = 0x30, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.y_deltvel		= {.reg_addr = 0x34, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.z_deltvel		= {.reg_addr = 0x38, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.fifo_cnt		= {.reg_addr = 0x3C, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.spi_chksum		= {.reg_addr = 0x3E, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.xg_bias		= {.reg_addr = 0x40, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.yg_bias		= {.reg_addr = 0x44, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.zg_bias		= {.reg_addr = 0x48, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.xa_bias		= {.reg_addr = 0x4C, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.ya_bias		= {.reg_addr = 0x50, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.za_bias		= {.reg_addr = 0x54, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.fifo_en		= {.reg_addr = 0x5A, .reg_size = 0x02, .field_mask = BIT(0)},
	.fifo_overflow		= {.reg_addr = 0x5A, .reg_size = 0x02, .field_mask = BIT(1)},
	.fifo_wm_int_en		= {.reg_addr = 0x5A, .reg_size = 0x02, .field_mask = BIT(2)},
	.fifo_wm_int_pol	= {.reg_addr = 0x5A, .reg_size = 0x02, .field_mask = BIT(3)},
	.fifo_wm_lvl		= {.reg_addr = 0x5A, .reg_size = 0x02, .field_mask = 0x0000FFF0},
	.filt_size_var_b	= {.reg_addr = 0x5C, .reg_size = 0x02, .field_mask = 0x00000007},
	.up_scale		= {.reg_addr = 0x62, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.dec_rate		= {.reg_addr = 0x64, .reg_size = 0x02, .field_mask = 0x00000FFF},
	.gyro_meas_range	= {.reg_addr = 0x5E, .reg_size = 0x02, .field_mask = 0x0000000C},
	.firm_rev		= {.reg_addr = 0x6C, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.firm_d			= {.reg_addr = 0x6E, .reg_size = 0x02, .field_mask = 0x000000FF},
	.firm_m			= {.reg_addr = 0x6E, .reg_size = 0x02, .field_mask = 0x0000FF00},
	.firm_y			= {.reg_addr = 0x70, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.prod_id		= {.reg_addr = 0x72, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.serial_num		= {.reg_addr = 0x74, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.usr_scr_1		= {.reg_addr = 0x76, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.usr_scr_2		= {.reg_addr = 0x78, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.usr_scr_3		= {.reg_addr = 0x7A, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.fls_mem_wr_cntr	= {.reg_addr = 0x7C, .reg_size = 0x04, .field_mask = 0xFFFFFFFF},
	.msc_ctrl		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.dr_polarity		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(0)},
	.sync_polarity		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(1)},
	.sync_mode		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = 0x0000000C},
	.pt_of_perc_algnmt	= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(6)},
	.linear_accl_comp	= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(7)},
	.burst_sel		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(8)},
	.burst32		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(9)},
	.timestamp32		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(10)},
	.sync_4khz		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(11)},
	.sens_bw		= {.reg_addr = 0x60, .reg_size = 0x02, .field_mask = BIT(12)},
	.bias_corr_tbc		= {.reg_addr = 0x66, .reg_size = 0x02, .field_mask = 0x0000000F},
	.bias_corr_en_xg	= {.reg_addr = 0x66, .reg_size = 0x02, .field_mask = BIT(8)},
	.bias_corr_en_yg	= {.reg_addr = 0x66, .reg_size = 0x02, .field_mask = BIT(9)},
	.bias_corr_en_zg	= {.reg_addr = 0x66, .reg_size = 0x02, .field_mask = BIT(10)},
	.bias_corr_en_xa	= {.reg_addr = 0x66, .reg_size = 0x02, .field_mask = BIT(11)},
	.bias_corr_en_ya	= {.reg_addr = 0x66, .reg_size = 0x02, .field_mask = BIT(12)},
	.bias_corr_en_za	= {.reg_addr = 0x66, .reg_size = 0x02, .field_mask = BIT(13)},
	.glob_cmd		= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = 0x0000FFFF},
	.bias_corr_update	= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = BIT(0)},
	.fact_calib_restore	= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = BIT(1)},
	.snsr_self_test		= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = BIT(2)},
	.fls_mem_update		= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = BIT(3)},
	.fls_mem_test		= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = BIT(4)},
	.fifo_flush		= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = BIT(5)},
	.sw_res			= {.reg_addr = 0x68, .reg_size = 0x02, .field_mask = BIT(7)},
	.diag_stat		= {.reg_addr = 0x02, .reg_size = 0x02, .field_mask = 0x0000BFFF},
	.diag_snsr_init_failure_mask		= BIT(0),
	.diag_data_path_overrun_mask		= BIT(1),
	.diag_fls_mem_update_failure_mask	= BIT(2),
	.diag_spi_comm_err_mask			= BIT(3),
	.diag_standby_mode_mask			= BIT(4),
	.diag_snsr_failure_mask			= BIT(5),
	.diag_mem_failure_mask			= BIT(6),
	.diag_clk_err_mask			= BIT(7),
	.diag_x_axis_gyro_failure_mask		= BIT(8),
	.diag_y_axis_gyro_failure_mask		= BIT(9),
	.diag_z_axis_gyro_failure_mask		= BIT(10),
	.diag_x_axis_accl_failure_mask		= BIT(11),
	.diag_y_axis_accl_failure_mask		= BIT(12),
	.diag_z_axis_accl_failure_mask		= BIT(13),
	.diag_aduc_mcu_fault_mask		= BIT(15),
};

static const struct iio_chan_spec adis1657x_channels[] = {
	ADIS_EXTD_GYRO_CHAN(adis1657x_def.x_gyro.reg_addr,  X, 32, 32),
	ADIS_EXTD_GYRO_CHAN(adis1657x_def.y_gyro.reg_addr,  Y, 32, 32),
	ADIS_EXTD_GYRO_CHAN(adis1657x_def.z_gyro.reg_addr,  Z, 32, 32),
	ADIS_EXTD_ACCEL_CHAN(adis1657x_def.x_accl.reg_addr, X, 32, 32),
	ADIS_EXTD_ACCEL_CHAN(adis1657x_def.y_accl.reg_addr, Y, 32, 32),
	ADIS_EXTD_ACCEL_CHAN(adis1657x_def.z_accl.reg_addr, Z, 32, 32),
	ADIS_EXTD_TEMP_CHAN(adis1657x_def,                     32, 32),
	ADIS_EXTD_DELTA_ANGL_CHAN(adis1657x_def.x_deltang.reg_addr, X, 32, 32),
	ADIS_EXTD_DELTA_ANGL_CHAN(adis1657x_def.y_deltang.reg_addr, Y, 32, 32),
	ADIS_EXTD_DELTA_ANGL_CHAN(adis1657x_def.z_deltang.reg_addr, Z, 32, 32),
	ADIS_EXTD_DELTA_VEL_CHAN(adis1657x_def.x_deltvel.reg_addr,  X, 32, 32),
	ADIS_EXTD_DELTA_VEL_CHAN(adis1657x_def.y_deltvel.reg_addr,  Y, 32, 32),
	ADIS_EXTD_DELTA_VEL_CHAN(adis1657x_def.z_deltvel.reg_addr,  Z, 32, 32),
	IIO_CHAN_SOFT_TIMESTAMP(13)
};

static const struct adis_extd_clk_freq_limit adis1657x_sync_mode[] = {
	[ADIS_EXTD_SYNC_DEFAULT] = { },
	[ADIS_EXTD_SYNC_DIRECT] = {1900, 4100},
	[ADIS_EXTD_SYNC_SCALED] = {1, 400},
	[ADIS_EXTD_SYNC_OUTPUT] = { },
};

static const struct adis_timeout adis1657x_adis_timeouts = {
	.reset_ms = 350,
	.sw_reset_ms = 350,
	.self_test_ms = 30,
};

static const struct adis_extd_clk_freq_limit adis1657x_sampling_clk_limits = {
	.min_freq = 1900,
	.max_freq = 4000,
};

static const struct adis_extd_timeout adis1657x_timeouts = {
	.reset_ms			= 350,
	.fact_calib_restore_ms		= 150,
	.self_test_ms			= 30,
	.fls_mem_update_ms		= 70,
	.fls_mem_test_ms		= 30,
	.sw_reset_ms			= 350,
	.filt_size_var_b_update_us	= 30,
	.dec_rate_update_us		= 30,
	.msc_reg_update_us		= 200,
	.sens_bw_update_ms		= 250,
};

static const struct adis_extd_chip_info adis1657x_chip_info[] = {
	[ADIS16575_2] = {
		.name = "adis16575-2",
		.num_channels = ARRAY_SIZE(adis1657x_channels),
		.channels = adis1657x_channels,
		.gyro_scale = {1, IIO_RAD_TO_DEGREE(2621440)},
		.accl_scale = {1, 26731249},
		.temp_scale = {1 * MILLIDEGREE_PER_DEGREE, 10},
		.rot_scale = {450, 31},
		.vel_scale = {100, 31},
		.int_clk = 4000,
		.sync_clk_freq_limits = adis1657x_sync_mode,
		.adis_data = ADIS_EXTD_DATA(adis1657x_def.msc_ctrl.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    adis1657x_def.diag_stat.reg_addr,
					    adis1657x_def.prod_id.reg_addr,
					    adis1657x_def.snsr_self_test.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    16575,
					    &adis1657x_adis_timeouts,
					    8000000,
					    5,
					    0,
					    0),
		.field_map = &adis1657x_def,
		.sync_mode_max = 3,
		.fls_mem_wr_cntr_max = 100000,
		.filt_size_var_b_max = 6,
		.dec_rate_max = 3999,
		.timeouts = &adis1657x_timeouts,
		.sampling_clk_limits	= adis1657x_sampling_clk_limits,
		.bias_corr_tbc_max = 12,
		.has_fifo = true,
		.burst32_extra_bytes = 14,
	},
	[ADIS16575_3] = {
		.name = "adis16575-3",
		.num_channels = ARRAY_SIZE(adis1657x_channels),
		.channels = adis1657x_channels,
		.gyro_scale = {1, IIO_RAD_TO_DEGREE(655360)},
		.accl_scale = {1, 26731249},
		.temp_scale = {1 * MILLIDEGREE_PER_DEGREE, 10},
		.rot_scale = {2000, 31},
		.vel_scale = {100, 31},
		.int_clk = 4000,
		.sync_clk_freq_limits = adis1657x_sync_mode,
		.adis_data = ADIS_EXTD_DATA(adis1657x_def.msc_ctrl.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    adis1657x_def.diag_stat.reg_addr,
					    adis1657x_def.prod_id.reg_addr,
					    adis1657x_def.snsr_self_test.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    16575,
					    &adis1657x_adis_timeouts,
					    8000000,
					    5,
					    0,
					    0),
		.field_map = &adis1657x_def,
		.sync_mode_max = 3,
		.fls_mem_wr_cntr_max = 100000,
		.filt_size_var_b_max = 6,
		.dec_rate_max = 3999,
		.timeouts = &adis1657x_timeouts,
		.sampling_clk_limits	= adis1657x_sampling_clk_limits,
		.bias_corr_tbc_max = 12,
		.has_fifo = true,
		.burst32_extra_bytes = 14,
	},
	[ADIS16576_2] = {
		.name = "adis16576-2",
		.num_channels = ARRAY_SIZE(adis1657x_channels),
		.channels = adis1657x_channels,
		.gyro_scale = {1, IIO_RAD_TO_DEGREE(2621440)},
		.accl_scale = {1, 5346250},
		.temp_scale = {1 * MILLIDEGREE_PER_DEGREE, 10},
		.rot_scale = {450, 31},
		.vel_scale = {100, 31},
		.int_clk = 4000,
		.sync_clk_freq_limits = adis1657x_sync_mode,
		.adis_data = ADIS_EXTD_DATA(adis1657x_def.msc_ctrl.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    adis1657x_def.diag_stat.reg_addr,
					    adis1657x_def.prod_id.reg_addr,
					    adis1657x_def.snsr_self_test.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    16576,
					    &adis1657x_adis_timeouts,
					    8000000,
					    5,
					    0,
					    0),
		.field_map = &adis1657x_def,
		.sync_mode_max = 3,
		.fls_mem_wr_cntr_max = 100000,
		.filt_size_var_b_max = 6,
		.dec_rate_max = 3999,
		.timeouts = &adis1657x_timeouts,
		.sampling_clk_limits	= adis1657x_sampling_clk_limits,
		.bias_corr_tbc_max = 12,
		.has_fifo = true,
		.burst32_extra_bytes = 14,
	},
	[ADIS16576_3] = {
		.name = "adis16576-3",
		.num_channels = ARRAY_SIZE(adis1657x_channels),
		.channels = adis1657x_channels,
		.gyro_scale = {1, IIO_RAD_TO_DEGREE(655360)},
		.accl_scale = {1, 5346250},
		.temp_scale = {1 * MILLIDEGREE_PER_DEGREE, 10},
		.rot_scale = {2000, 31},
		.vel_scale = {100, 31},
		.int_clk = 4000,
		.sync_clk_freq_limits = adis1657x_sync_mode,
		.adis_data = ADIS_EXTD_DATA(adis1657x_def.msc_ctrl.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    adis1657x_def.diag_stat.reg_addr,
					    adis1657x_def.prod_id.reg_addr,
					    adis1657x_def.snsr_self_test.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    16576,
					    &adis1657x_adis_timeouts,
					    8000000,
					    5,
					    0,
					    0),
		.field_map = &adis1657x_def,
		.sync_mode_max = 3,
		.fls_mem_wr_cntr_max = 100000,
		.filt_size_var_b_max = 6,
		.dec_rate_max = 3999,
		.timeouts = &adis1657x_timeouts,
		.sampling_clk_limits	= adis1657x_sampling_clk_limits,
		.bias_corr_tbc_max = 12,
		.has_fifo = true,
		.burst32_extra_bytes = 14,
	},
	[ADIS16577_2] = {
		.name = "adis16577-2",
		.num_channels = ARRAY_SIZE(adis1657x_channels),
		.channels = adis1657x_channels,
		.gyro_scale = {1, IIO_RAD_TO_DEGREE(2621440)},
		.accl_scale = {1, 5346250},
		.temp_scale = {1 * MILLIDEGREE_PER_DEGREE, 10},
		.rot_scale = {450, 31},
		.vel_scale = {100, 31},
		.int_clk = 4000,
		.sync_clk_freq_limits = adis1657x_sync_mode,
		.adis_data = ADIS_EXTD_DATA(adis1657x_def.msc_ctrl.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    adis1657x_def.diag_stat.reg_addr,
					    adis1657x_def.prod_id.reg_addr,
					    adis1657x_def.snsr_self_test.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    16577,
					    &adis1657x_adis_timeouts,
					    8000000,
					    5,
					    0,
					    0),
		.field_map = &adis1657x_def,
		.sync_mode_max = 3,
		.fls_mem_wr_cntr_max = 100000,
		.filt_size_var_b_max = 6,
		.dec_rate_max = 3999,
		.timeouts = &adis1657x_timeouts,
		.sampling_clk_limits	= adis1657x_sampling_clk_limits,
		.bias_corr_tbc_max = 12,
		.has_fifo = true,
		.burst32_extra_bytes = 14,
	},
	[ADIS16577_3] = {
		.name = "adis16577-3",
		.num_channels = ARRAY_SIZE(adis1657x_channels),
		.channels = adis1657x_channels,
		.gyro_scale = {1, IIO_RAD_TO_DEGREE(655360)},
		.accl_scale = {1, 5346250},
		.temp_scale = {1 * MILLIDEGREE_PER_DEGREE, 10},
		.rot_scale = {2000, 31},
		.vel_scale = {100, 31},
		.int_clk = 4000,
		.sync_clk_freq_limits = adis1657x_sync_mode,
		.adis_data = ADIS_EXTD_DATA(adis1657x_def.msc_ctrl.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    adis1657x_def.diag_stat.reg_addr,
					    adis1657x_def.prod_id.reg_addr,
					    adis1657x_def.snsr_self_test.reg_addr,
					    adis1657x_def.glob_cmd.reg_addr,
					    16577,
					    &adis1657x_adis_timeouts,
					    8000000,
					    5,
					    0,
					    0),
		.field_map = &adis1657x_def,
		.sync_mode_max = 3,
		.fls_mem_wr_cntr_max = 100000,
		.filt_size_var_b_max = 6,
		.dec_rate_max = 3999,
		.timeouts = &adis1657x_timeouts,
		.sampling_clk_limits	= adis1657x_sampling_clk_limits,
		.bias_corr_tbc_max = 12,
		.has_fifo = true,
		.burst32_extra_bytes = 14,
	},
};

static const enum adis_extd_debug_attr adis1657x_debug_attr[] = {
	ADIS_EXTD_DIAG_SNSR_INIT_FAILURE,
	ADIS_EXTD_DIAG_DATA_PATH_OVERRUN,
	ADIS_EXTD_DIAG_FLS_MEM_UPDATE_FAILURE,
	ADIS_EXTD_DIAG_SPI_COMM_ERR,
	ADIS_EXTD_DIAG_STANDBY_MODE,
	ADIS_EXTD_DIAG_SNSR_FAILURE,
	ADIS_EXTD_DIAG_MEM_FAILURE,
	ADIS_EXTD_DIAG_CLK_ERR,
	ADIS_EXTD_DIAG_X_AXIS_GYRO_FAILURE,
	ADIS_EXTD_DIAG_Y_AXIS_GYRO_FAILURE,
	ADIS_EXTD_DIAG_Z_AXIS_GYRO_FAILURE,
	ADIS_EXTD_DIAG_X_AXIS_ACCL_FAILURE,
	ADIS_EXTD_DIAG_Y_AXIS_ACCL_FAILURE,
	ADIS_EXTD_DIAG_Z_AXIS_ACCL_FAILURE,
	ADIS_EXTD_DIAG_ADUC_MCU_FAULT,
	ADIS_EXTD_DIAG_CHECKSUM_ERR,
	ADIS_EXTD_DIAG_FLS_MEM_WR_CNT_EXCEED,
	ADIS_EXTD_DIAG_LOST_SAMPLES_COUNT,
	ADIS_EXTD_TIME_STAMP,
	ADIS_EXTD_DATA_CNTR,
	ADIS_EXTD_FIFO_CNT,
	ADIS_EXTD_SPI_CHKSUM,
	ADIS_EXTD_FIFO_EN,
	ADIS_EXTD_FIFO_OVERFLOW,
	ADIS_EXTD_FIFO_WM_INT_EN,
	ADIS_EXTD_FIFO_WM_INT_POL,
	ADIS_EXTD_FIFO_WM_LVL,
	ADIS_EXTD_FILT_SIZE_VAR_B,
	ADIS_EXTD_GYRO_MEAS_RANGE,
	ADIS_EXTD_DR_POLARITY,
	ADIS_EXTD_SYNC_POLARITY,
	ADIS_EXTD_SYNC_MODE,
	ADIS_EXTD_SENS_BW,
	ADIS_EXTD_PT_OF_PERC_ALGNMT,
	ADIS_EXTD_LINEAR_ACCL_COMP,
	ADIS_EXTD_BURST_SEL,
	ADIS_EXTD_BURST32,
	ADIS_EXTD_TIMESTAMP32,
	ADIS_EXTD_SYNC_4KHZ,
	ADIS_EXTD_UP_SCALE,
	ADIS_EXTD_DEC_RATE,
	ADIS_EXTD_BIAS_CORR_TBC,
	ADIS_EXTD_BIAS_CORR_EN_XG,
	ADIS_EXTD_BIAS_CORR_EN_YG,
	ADIS_EXTD_BIAS_CORR_EN_ZG,
	ADIS_EXTD_BIAS_CORR_EN_XA,
	ADIS_EXTD_BIAS_CORR_EN_YA,
	ADIS_EXTD_BIAS_CORR_EN_ZA,
	ADIS_EXTD_CMD_BIAS_CORR_UPDATE,
	ADIS_EXTD_CMD_FACT_CALIB_RESTORE,
	ADIS_EXTD_CMD_SNSR_SELF_TEST,
	ADIS_EXTD_CMD_FLS_MEM_UPDATE,
	ADIS_EXTD_CMD_FLS_MEM_TEST,
	ADIS_EXTD_CMD_FIFO_FLUSH,
	ADIS_EXTD_CMD_SW_RES,
	ADIS_EXTD_FIRM_REV,
	ADIS_EXTD_FIRM_DATE,
	ADIS_EXTD_PROD_ID,
	ADIS_EXTD_SERIAL_NUM,
	ADIS_EXTD_USR_SCR_1,
	ADIS_EXTD_USR_SCR_2,
	ADIS_EXTD_USR_SCR_3,
	ADIS_EXTD_FLS_MEM_WR_CNTR,
};

static const struct of_device_id adis1657x_of_match[] = {
	{
		.compatible = "adi,adis16575-2_extd",
		.data = &adis1657x_chip_info[ADIS16575_2]
	},
	{
		.compatible = "adi,adis16575-3_extd",
		.data = &adis1657x_chip_info[ADIS16575_3]
	},
	{
		.compatible = "adi,adis16576-2_extd",
		.data = &adis1657x_chip_info[ADIS16576_2]
	},
	{
		.compatible = "adi,adis16576-3_extd",
		.data = &adis1657x_chip_info[ADIS16576_3]
	},
	{
		.compatible = "adi,adis16577-2_extd",
		.data = &adis1657x_chip_info[ADIS16577_2]
	},
	{
		.compatible = "adi,adis16577-3_extd",
		.data = &adis1657x_chip_info[ADIS16577_3]
	},
	{ },
};
MODULE_DEVICE_TABLE(of, adis1657x_of_match);

static const struct spi_device_id adis1657x_spi_id[] = {
	{ "adis16575-2_extd", (kernel_ulong_t)&adis1657x_of_match[ADIS16575_2] },
	{ "adis16575-3_extd", (kernel_ulong_t)&adis1657x_of_match[ADIS16575_3] },
	{ "adis16576-2_extd", (kernel_ulong_t)&adis1657x_of_match[ADIS16576_2] },
	{ "adis16576-3_extd", (kernel_ulong_t)&adis1657x_of_match[ADIS16576_3] },
	{ "adis16577-2_extd", (kernel_ulong_t)&adis1657x_of_match[ADIS16577_2] },
	{ "adis16577-3_extd", (kernel_ulong_t)&adis1657x_of_match[ADIS16577_3] },
	{ }
};
MODULE_DEVICE_TABLE(spi, adis1657x_spi_id);

static int adis1657x_probe(struct spi_device *spi)
{
	return adis_extd_init(spi, adis1657x_debug_attr,
			      ARRAY_SIZE(adis1657x_debug_attr));
}

static struct spi_driver adis1657x_driver = {
	.driver = {
		.name = "adis1657x",
		.of_match_table = adis1657x_of_match,
	},
	.probe = adis1657x_probe,
	.id_table = adis1657x_spi_id,
};
module_spi_driver(adis1657x_driver);

MODULE_AUTHOR("Ramona Bolboaca <ramona.bolboaca@analog.com>");
MODULE_DESCRIPTION("Analog Devices adis1657x IMU driver");
MODULE_LICENSE("GPL");
MODULE_IMPORT_NS(IIO_ADISLIB);
MODULE_IMPORT_NS(IIO_ADIS_EXTDLIB);
